name: Build and Release Talos Unified Images

on:
  push:
    # branches:
    #   - 'renovate/siderolabs-talos-*'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      TALOS_VERSION: v1.12.0
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Set up build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zstd qemu-utils tar gzip curl gnupg jq

      - name: Build unified images
        run: |
          chmod +x scripts/build-image.sh
          echo "Building amd64 image..."
          ./scripts/build-image.sh "${TALOS_VERSION}" amd64
          echo "Building arm64 image..."
          ./scripts/build-image.sh "${TALOS_VERSION}" arm64

      - name: Verify artifacts
        run: |
          if [ ! -f "incus-amd64.tar.xz" ]; then
            echo "Error: incus-amd64.tar.xz not found"
            exit 1
          fi
          if [ ! -f "incus-arm64.tar.xz" ]; then
            echo "Error: incus-arm64.tar.xz not found"
            exit 1
          fi
          echo "✓ Both artifacts verified:"
          ls -lh incus-*.tar.xz

      - name: Calculate SHA256 hashes and sizes
        id: hashes
        run: |
          AMD64_HASH=$(sha256sum incus-amd64.tar.xz | cut -d' ' -f1)
          ARM64_HASH=$(sha256sum incus-arm64.tar.xz | cut -d' ' -f1)
          AMD64_SIZE=$(stat -c%s incus-amd64.tar.xz)
          ARM64_SIZE=$(stat -c%s incus-arm64.tar.xz)
          CREATION_DATE=$(date +%s)
          
          echo "amd64_hash=${AMD64_HASH}" >> $GITHUB_OUTPUT
          echo "arm64_hash=${ARM64_HASH}" >> $GITHUB_OUTPUT
          echo "amd64_size=${AMD64_SIZE}" >> $GITHUB_OUTPUT
          echo "arm64_size=${ARM64_SIZE}" >> $GITHUB_OUTPUT
          echo "creation_date=${CREATION_DATE}" >> $GITHUB_OUTPUT
          
          echo "✓ Hashes and sizes calculated:"
          echo "  AMD64: ${AMD64_HASH} (${AMD64_SIZE} bytes)"
          echo "  ARM64: ${ARM64_HASH} (${ARM64_SIZE} bytes)"
      
      - name: Verify artifacts exist and match hashes
        run: |
          # Recalculate hashes from files to verify they match
          AMD64_VERIFY_HASH=$(sha256sum incus-amd64.tar.xz | cut -d' ' -f1)
          ARM64_VERIFY_HASH=$(sha256sum incus-arm64.tar.xz | cut -d' ' -f1)
          
          if [ "${AMD64_VERIFY_HASH}" != "${{ steps.hashes.outputs.amd64_hash }}" ]; then
            echo "Error: AMD64 hash mismatch!"
            echo "  Calculated: ${{ steps.hashes.outputs.amd64_hash }}"
            echo "  Verified: ${AMD64_VERIFY_HASH}"
            exit 1
          fi
          
          if [ "${ARM64_VERIFY_HASH}" != "${{ steps.hashes.outputs.arm64_hash }}" ]; then
            echo "Error: ARM64 hash mismatch!"
            echo "  Calculated: ${{ steps.hashes.outputs.arm64_hash }}"
            echo "  Verified: ${ARM64_VERIFY_HASH}"
            exit 1
          fi
          
          echo "✓ Hash verification passed for both architectures"

      - name: Import GPG key
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d | gpg --batch --import
          gpg --list-secret-keys --keyid-format LONG
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Sign artifacts
        run: |
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep '^sec' | awk '{print $2}' | cut -d'/' -f2 | head -1)
          echo "Signing with key: ${GPG_KEY_ID}"
          gpg --batch --yes --detach-sign --armor \
            --pinentry-mode loopback \
            --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
            -u "${GPG_KEY_ID}" \
            -o incus-amd64.tar.xz.asc \
            incus-amd64.tar.xz
          gpg --batch --yes --detach-sign --armor \
            --pinentry-mode loopback \
            --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
            -u "${GPG_KEY_ID}" \
            -o incus-arm64.tar.xz.asc \
            incus-arm64.tar.xz
          echo "✓ Signatures created:"
          ls -lh *.asc
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Look up KV namespace ID by name
        id: kv_namespace
        run: |
          # Look up namespace by name (same as deploy workflow)
          NAMESPACE_NAME="windsorcli-dev-images"
          NAMESPACE_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/storage/kv/namespaces" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" | \
            python3 -c "import sys, json; data=json.load(sys.stdin); ns=[n for n in data.get('result', []) if n.get('title') == '$NAMESPACE_NAME']; print(ns[0]['id'] if ns else '')" || echo "")
          
          if [ -z "$NAMESPACE_ID" ]; then
            echo "Error: KV namespace '$NAMESPACE_NAME' not found"
            echo "Please ensure the namespace exists in Cloudflare Dashboard"
            exit 1
          fi
          
          echo "namespace_id=$NAMESPACE_ID" >> $GITHUB_OUTPUT
          echo "✓ Found KV namespace '$NAMESPACE_NAME' with ID: $NAMESPACE_ID"

      - name: Upload metadata to Cloudflare KV
        run: |
          # Upload metadata to KV store for simplestream support
          # Key format: product:talos:{version}:{arch}:{variant}
          # Value: JSON with hash, size, creation_date
          # Also maintain products:list -> array of product keys (lightweight, just strings)
          REPO="talos-incus"
          
          # Trim whitespace and verify hash format (64 hex chars)
          AMD64_HASH=$(echo "${{ steps.hashes.outputs.amd64_hash }}" | tr -d '[:space:]')
          ARM64_HASH=$(echo "${{ steps.hashes.outputs.arm64_hash }}" | tr -d '[:space:]')
          AMD64_SIZE="${{ steps.hashes.outputs.amd64_size }}"
          ARM64_SIZE="${{ steps.hashes.outputs.arm64_size }}"
          CREATION_DATE="${{ steps.hashes.outputs.creation_date }}"
          
          if [ ${#AMD64_HASH} -ne 64 ] || [ ${#ARM64_HASH} -ne 64 ]; then
            echo "Error: Invalid hash length (expected 64 hex characters)"
            echo "AMD64 hash length: ${#AMD64_HASH}"
            echo "ARM64 hash length: ${#ARM64_HASH}"
            exit 1
          fi
          
          # Product keys (consistent format for all entries)
          PRODUCT_AMD64="product:talos:${TALOS_VERSION}:amd64:default"
          PRODUCT_ARM64="product:talos:${TALOS_VERSION}:arm64:default"
          
          # Create metadata JSON for each architecture (unified format)
          AMD64_METADATA=$(jq -n \
            --arg hash "${AMD64_HASH}" \
            --arg size "${AMD64_SIZE}" \
            --arg date "${CREATION_DATE}" \
            '{hash: $hash, size: ($size | tonumber), creation_date: $date}')
          
          ARM64_METADATA=$(jq -n \
            --arg hash "${ARM64_HASH}" \
            --arg size "${ARM64_SIZE}" \
            --arg date "${CREATION_DATE}" \
            '{hash: $hash, size: ($size | tonumber), creation_date: $date}')
          
          echo "Uploading metadata to KV:"
          echo "  AMD64: ${AMD64_HASH} (${AMD64_SIZE} bytes)"
          echo "  ARM64: ${ARM64_HASH} (${ARM64_SIZE} bytes)"
          
          NAMESPACE_ID="${{ steps.kv_namespace.outputs.namespace_id }}"
          API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          ACCOUNT_ID="${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          
          # Upload product metadata (unified format - replaces old backward-compatible entries)
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/${PRODUCT_AMD64}" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "${AMD64_METADATA}"
          
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/${PRODUCT_ARM64}" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "${ARM64_METADATA}"
          
          # Update products list (lightweight array of product keys, just strings)
          # This list is small - each entry is just a string like "product:talos:v1.12.0:amd64:default"
          PRODUCTS_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/products:list" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" 2>&1) || true
          
          # Initialize with empty array as default
          EXISTING_PRODUCTS="[]"
          
          # Check if we got a valid response
          if [ -z "${PRODUCTS_RESPONSE}" ]; then
            echo "Note: products:list key doesn't exist yet (first run), starting with empty array"
          elif ! echo "${PRODUCTS_RESPONSE}" | jq -e '.success == true' >/dev/null 2>&1; then
            echo "Warning: Failed to parse products list response, using empty array"
            echo "  Response: ${PRODUCTS_RESPONSE:0:200}..."
          else
            # Extract the result field (KV stores JSON as a string, so result is a JSON string)
            # If result is null or missing, default to empty array
            RESULT_VALUE=$(echo "${PRODUCTS_RESPONSE}" | jq -r '.result // "[]"' 2>/dev/null || echo "[]")
            
            # If result is the literal string "null", treat as empty
            if [ "${RESULT_VALUE}" = "null" ] || [ -z "${RESULT_VALUE}" ]; then
              EXISTING_PRODUCTS="[]"
            else
              EXISTING_PRODUCTS="${RESULT_VALUE}"
            fi
          fi
          
          # Validate it's a valid JSON array (always succeeds, defaults to empty array if invalid)
          if ! echo "${EXISTING_PRODUCTS}" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "Warning: Invalid products list format, resetting to empty array"
            echo "  Received: ${EXISTING_PRODUCTS:0:100}..."
            EXISTING_PRODUCTS="[]"
          fi
          
          # Add new products if not already present (idempotent)
          # Product keys format: product:talos:{version}:{arch}:{variant}
          UPDATED_PRODUCTS=$(echo "${EXISTING_PRODUCTS}" | jq --arg p1 "${PRODUCT_AMD64}" --arg p2 "${PRODUCT_ARM64}" \
            'if index($p1) == null then . + [$p1] else . end | if index($p2) == null then . + [$p2] else . end' 2>/dev/null || echo "[]")
          
          # Validate the updated products list is valid JSON
          if ! echo "${UPDATED_PRODUCTS}" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "Error: Failed to generate valid products list"
            echo "  EXISTING_PRODUCTS: ${EXISTING_PRODUCTS}"
            echo "  UPDATED_PRODUCTS: ${UPDATED_PRODUCTS}"
            exit 1
          fi
          
          echo "Products list updated:"
          echo "${UPDATED_PRODUCTS}" | jq '. | length' | xargs echo "  Total products:"
          
          # Upload the updated products list
          PUT_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/products:list" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "${UPDATED_PRODUCTS}")
          
          # Verify the upload succeeded
          if ! echo "${PUT_RESPONSE}" | jq -e '.success == true' >/dev/null 2>&1; then
            echo "Error: Failed to upload products list to KV"
            echo "  Response: ${PUT_RESPONSE}"
            exit 1
          fi
          
          echo "✓ Metadata uploaded to Cloudflare KV"

          - name: Create GitHub Release
            run: |
              # Build file list for release
              RELEASE_FILES=("incus-amd64.tar.xz" "incus-arm64.tar.xz" "incus-amd64.tar.xz.asc" "incus-arm64.tar.xz.asc")
              
              NOTES="Automated release of Talos OS unified images for Incus.
              
              **Version:** ${TALOS_VERSION}
              
              **Architectures:**
              - amd64 (x86_64)
              - arm64 (aarch64)
              
              **Usage:**
              
              **AMD64:**
              \`\`\`bash
              incus image import https://images.windsorcli.dev/talos-incus/${TALOS_VERSION}/incus-amd64.tar.xz --alias talos-${TALOS_VERSION}-amd64
              incus launch talos-${TALOS_VERSION}-amd64 my-talos-instance
              \`\`\`
              
              **ARM64:**
              \`\`\`bash
              incus image import https://images.windsorcli.dev/talos-incus/${TALOS_VERSION}/incus-arm64.tar.xz --alias talos-${TALOS_VERSION}-arm64
              incus launch talos-${TALOS_VERSION}-arm64 my-talos-instance
              \`\`\`
              
              **Verification:**
              \`\`\`bash
              gpg --verify incus-amd64.tar.xz.asc incus-amd64.tar.xz
              gpg --verify incus-arm64.tar.xz.asc incus-arm64.tar.xz
              \`\`\`"
          
          gh release create "${TALOS_VERSION}" \
            --title "Talos ${TALOS_VERSION}" \
            --notes "${NOTES}" \
            --latest \
            "${RELEASE_FILES[@]}"
        env:
          GH_TOKEN: ${{ github.token }}
