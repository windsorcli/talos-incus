name: Build and Release Talos Unified Images

on:
  push:
    # branches:
    #   - 'renovate/siderolabs-talos-*'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      TALOS_VERSION: v1.12.0
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Set up build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zstd qemu-utils tar gzip curl gnupg jq

      - name: Build unified images
        run: |
          chmod +x scripts/build-image.sh
          echo "Building amd64 image..."
          ./scripts/build-image.sh "${TALOS_VERSION}" amd64
          echo "Building arm64 image..."
          ./scripts/build-image.sh "${TALOS_VERSION}" arm64

      - name: Verify artifacts
        run: |
          if [ ! -f "incus-amd64.tar.gz" ]; then
            echo "Error: incus-amd64.tar.gz not found"
            exit 1
          fi
          if [ ! -f "incus-arm64.tar.gz" ]; then
            echo "Error: incus-arm64.tar.gz not found"
            exit 1
          fi
          echo "✓ Both artifacts verified:"
          ls -lh incus-*.tar.gz

      - name: Calculate SHA256 hashes and sizes
        id: hashes
        run: |
          AMD64_HASH=$(sha256sum incus-amd64.tar.gz | cut -d' ' -f1)
          ARM64_HASH=$(sha256sum incus-arm64.tar.gz | cut -d' ' -f1)
          AMD64_SIZE=$(stat -c%s incus-amd64.tar.gz)
          ARM64_SIZE=$(stat -c%s incus-arm64.tar.gz)
          CREATION_DATE=$(date +%s)
          
          echo "amd64_hash=${AMD64_HASH}" >> $GITHUB_OUTPUT
          echo "arm64_hash=${ARM64_HASH}" >> $GITHUB_OUTPUT
          echo "amd64_size=${AMD64_SIZE}" >> $GITHUB_OUTPUT
          echo "arm64_size=${ARM64_SIZE}" >> $GITHUB_OUTPUT
          echo "creation_date=${CREATION_DATE}" >> $GITHUB_OUTPUT
          
          echo "✓ Hashes and sizes calculated:"
          echo "  AMD64: ${AMD64_HASH} (${AMD64_SIZE} bytes)"
          echo "  ARM64: ${ARM64_HASH} (${ARM64_SIZE} bytes)"

      - name: Import GPG key
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d | gpg --batch --import
          gpg --list-secret-keys --keyid-format LONG
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Sign artifacts
        run: |
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep '^sec' | awk '{print $2}' | cut -d'/' -f2 | head -1)
          echo "Signing with key: ${GPG_KEY_ID}"
          gpg --batch --yes --detach-sign --armor \
            --pinentry-mode loopback \
            --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
            -u "${GPG_KEY_ID}" \
            -o incus-amd64.tar.gz.asc \
            incus-amd64.tar.gz
          gpg --batch --yes --detach-sign --armor \
            --pinentry-mode loopback \
            --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
            -u "${GPG_KEY_ID}" \
            -o incus-arm64.tar.gz.asc \
            incus-arm64.tar.gz
          echo "✓ Signatures created:"
          ls -lh *.asc
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Look up KV namespace ID by name
        id: kv_namespace
        run: |
          # Look up namespace by name (same as deploy workflow)
          NAMESPACE_NAME="windsorcli-dev-images"
          NAMESPACE_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/storage/kv/namespaces" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" | \
            python3 -c "import sys, json; data=json.load(sys.stdin); ns=[n for n in data.get('result', []) if n.get('title') == '$NAMESPACE_NAME']; print(ns[0]['id'] if ns else '')" || echo "")
          
          if [ -z "$NAMESPACE_ID" ]; then
            echo "Error: KV namespace '$NAMESPACE_NAME' not found"
            echo "Please ensure the namespace exists in Cloudflare Dashboard"
            exit 1
          fi
          
          echo "namespace_id=$NAMESPACE_ID" >> $GITHUB_OUTPUT
          echo "✓ Found KV namespace '$NAMESPACE_NAME' with ID: $NAMESPACE_ID"

      - name: Upload metadata to Cloudflare KV
        run: |
          # Upload metadata to KV store for simplestream support
          # Key formats:
          #   - {repo}:{version}:{arch} -> hash (backward compatible)
          #   - metadata:talos:{version}:{arch}:default -> full metadata JSON
          #   - products:list -> list of all product keys
          REPO="talos-incus"
          
          # Trim whitespace and verify hash format (64 hex chars)
          AMD64_HASH=$(echo "${{ steps.hashes.outputs.amd64_hash }}" | tr -d '[:space:]')
          ARM64_HASH=$(echo "${{ steps.hashes.outputs.arm64_hash }}" | tr -d '[:space:]')
          AMD64_SIZE="${{ steps.hashes.outputs.amd64_size }}"
          ARM64_SIZE="${{ steps.hashes.outputs.arm64_size }}"
          CREATION_DATE="${{ steps.hashes.outputs.creation_date }}"
          
          if [ ${#AMD64_HASH} -ne 64 ] || [ ${#ARM64_HASH} -ne 64 ]; then
            echo "Error: Invalid hash length (expected 64 hex characters)"
            echo "AMD64 hash length: ${#AMD64_HASH}"
            echo "ARM64 hash length: ${#ARM64_HASH}"
            exit 1
          fi
          
          # Product keys for simplestream
          PRODUCT_AMD64="talos:${TALOS_VERSION}:amd64:default"
          PRODUCT_ARM64="talos:${TALOS_VERSION}:arm64:default"
          
          # Create metadata JSON for each architecture
          AMD64_METADATA=$(jq -n \
            --arg hash "${AMD64_HASH}" \
            --arg size "${AMD64_SIZE}" \
            --arg date "${CREATION_DATE}" \
            '{hash: $hash, size: ($size | tonumber), creation_date: $date}')
          
          ARM64_METADATA=$(jq -n \
            --arg hash "${ARM64_HASH}" \
            --arg size "${ARM64_SIZE}" \
            --arg date "${CREATION_DATE}" \
            '{hash: $hash, size: ($size | tonumber), creation_date: $date}')
          
          echo "Uploading metadata to KV:"
          echo "  AMD64: ${AMD64_HASH} (${AMD64_SIZE} bytes)"
          echo "  ARM64: ${ARM64_HASH} (${ARM64_SIZE} bytes)"
          
          NAMESPACE_ID="${{ steps.kv_namespace.outputs.namespace_id }}"
          API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          ACCOUNT_ID="${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          
          # Upload hashes (backward compatible)
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/${REPO}:${TALOS_VERSION}:amd64" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: text/plain" \
            --data "${AMD64_HASH}"
          
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/${REPO}:${TALOS_VERSION}:arm64" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: text/plain" \
            --data "${ARM64_HASH}"
          
          # Upload full metadata for simplestream
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/metadata:${PRODUCT_AMD64}" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "${AMD64_METADATA}"
          
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/metadata:${PRODUCT_ARM64}" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "${ARM64_METADATA}"
          
          # Get existing products list and update it
          # Cloudflare KV API GET returns: {"result": "value", "success": true, ...}
          # If key doesn't exist: {"result": null, "success": true, ...}
          PRODUCTS_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/products:list" \
            -H "Authorization: Bearer ${API_TOKEN}")
          
          # Extract the actual value from API response, default to empty array if null or missing
          EXISTING_PRODUCTS=$(echo "${PRODUCTS_RESPONSE}" | jq -r '.result // "[]"')
          
          # Validate JSON format (result might be a JSON string that needs parsing)
          if echo "${EXISTING_PRODUCTS}" | jq -e 'type == "string"' >/dev/null 2>&1; then
            # If result is a JSON string, parse it
            EXISTING_PRODUCTS=$(echo "${EXISTING_PRODUCTS}" | jq -r '.')
          fi
          
          # Final validation - ensure it's a valid JSON array
          if ! echo "${EXISTING_PRODUCTS}" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "Warning: Invalid or missing products list, resetting to empty array"
            EXISTING_PRODUCTS="[]"
          fi
          
          # Add new products if not already present (idempotent)
          UPDATED_PRODUCTS=$(echo "${EXISTING_PRODUCTS}" | jq --arg p1 "${PRODUCT_AMD64}" --arg p2 "${PRODUCT_ARM64}" \
            'if index($p1) == null then . + [$p1] else . end | if index($p2) == null then . + [$p2] else . end')
          
          echo "Products list updated:"
          echo "${UPDATED_PRODUCTS}" | jq '. | length' | xargs echo "  Total products:"
          
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/storage/kv/namespaces/${NAMESPACE_ID}/values/products:list" \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "${UPDATED_PRODUCTS}"
          
          echo "✓ Metadata uploaded to Cloudflare KV"

      - name: Create GitHub Release
        run: |
          # Build file list for release
          RELEASE_FILES=("incus-amd64.tar.gz" "incus-arm64.tar.gz" "incus-amd64.tar.gz.asc" "incus-arm64.tar.gz.asc")
          
          NOTES="Automated release of Talos OS unified images for Incus.
          
          **Version:** ${TALOS_VERSION}
          
          **Architectures:**
          - amd64 (x86_64)
          - arm64 (aarch64)
          
          **Usage:**
          
          **AMD64:**
          \`\`\`bash
          incus image import https://images.windsorcli.dev/talos-incus/${TALOS_VERSION}/incus-amd64.tar.gz --alias talos-${TALOS_VERSION}-amd64
          incus launch talos-${TALOS_VERSION}-amd64 my-talos-instance
          \`\`\`
          
          **ARM64:**
          \`\`\`bash
          incus image import https://images.windsorcli.dev/talos-incus/${TALOS_VERSION}/incus-arm64.tar.gz --alias talos-${TALOS_VERSION}-arm64
          incus launch talos-${TALOS_VERSION}-arm64 my-talos-instance
          \`\`\`
          
          **Verification:**
          \`\`\`bash
          gpg --verify incus-amd64.tar.gz.asc incus-amd64.tar.gz
          gpg --verify incus-arm64.tar.gz.asc incus-arm64.tar.gz
          \`\`\`"
          
          gh release create "${TALOS_VERSION}" \
            --title "Talos ${TALOS_VERSION}" \
            --notes "${NOTES}" \
            "${RELEASE_FILES[@]}"
        env:
          GH_TOKEN: ${{ github.token }}
